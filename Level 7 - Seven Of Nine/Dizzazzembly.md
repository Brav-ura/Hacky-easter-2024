#reversing 
# Description
Have a look at this dizzazzembly.

When entering the flag, the corresponding program did output:

```
da.,.0w`-vv[evv[luj^&dUZ'pp*pp)cXb'ds
```
# Solution
Reading the assembly code gives an idea on what it does: scramble input by performing several operations. But having the original source code, or a script replicating it, will help in understanding how to decode the flag.

The instruction that doesn't seem as obvious to me is BINARY_SUBSCR. A quick search on it brings this URL as the first result https://docs.python.org/3/library/dis.html

From this we learn two things:
1. The instruction puts a list into the stack, the value for a key too, and stores that value in the list\[key\]
```
key = STACK.pop()
container = STACK.pop()
STACK.append(container[key])
```
2. This assembly code was generated by the `dis` Python library. This library turns python code into its assembly representation

So let's attempt to reverse engineer the code and compare our assumptions with the output of the dis function.

Let's start by creating a script that imports the library and defining a function to put the code and pass it to the disassemble library function.

```
import dis
def scramble():
	#code goes here

dis.dis(scramble)
```
For each line that is written, the dis function will be called to compare its output and ensure it matches.
## Line 1
```
  1           0 LOAD_CONST               0 (1337)
              2 STORE_NAME               0 (leet)
```
This just declares a variable leet that is equal to 1337
`leet = 1337`
## Line 2
```
  2           4 LOAD_NAME                1 (input)
              6 LOAD_CONST               1 ('enter the flag:')
              8 CALL_FUNCTION            1
             10 STORE_NAME               2 (flag)
```
This uses the input function to receive input interactively and stores that into a flag variable
`flag = input('enter the flag:')`
## Line 3

```
  3          12 LOAD_NAME                3 (list)
             14 LOAD_NAME                2 (flag)
             16 CALL_FUNCTION            1
             18 STORE_NAME               4 (l)
```
Creates a list l with the characters of the flag.
`l = list(flag)`
## Line 5
I guess it's technically line 4, but in the given code it's written like this. This is because if there's a blank line that also gets counted in the line numbers.
```
  5          20 LOAD_NAME                5 (range)
             22 LOAD_NAME                6 (len)
             24 LOAD_NAME                4 (l)
             26 CALL_FUNCTION            1
             28 CALL_FUNCTION            1
             30 GET_ITER
        >>   32 FOR_ITER                32 (to 66)
             34 STORE_NAME               7 (i)
```
This one creates a for loop that iterates over the range given by the length of the list with the characters of the flag.
`for i in range(len(l)):`
## Line 6
```
  6          36 LOAD_NAME                8 (chr)
             38 LOAD_NAME                9 (ord)
             40 LOAD_NAME                4 (l)
             42 LOAD_NAME                7 (i)
             44 BINARY_SUBSCR
             46 CALL_FUNCTION            1
             48 LOAD_NAME                0 (leet)
             50 LOAD_CONST               2 (10)
             52 BINARY_MODULO
             54 BINARY_SUBTRACT
             56 CALL_FUNCTION            1
             58 LOAD_NAME                4 (l)
             60 LOAD_NAME                7 (i)
             62 STORE_SUBSCR
             64 JUMP_ABSOLUTE           32
```
A bit more to unpack here. With a bit of trial and error we were able to get the correct order of the operations and the order of how the variables and constants are loaded.

This stores in the list `l` of characters in the position `i` the value of:
1. Call the `ord` function to get the integer that represents the character located at `l[i]`
2. Do `leet` modulo 10
3. Subtract to the value of bullet 1 the value of bullet 2
4. Get the corresponding character that represents that new calculated number

`l[i] = chr((ord(l[i]) - (leet % 10)))`
## Line 7
```
  7     >>   66 LOAD_NAME                0 (leet)
             68 LOAD_CONST               2 (10)
             70 BINARY_FLOOR_DIVIDE
             72 STORE_NAME               0 (leet)
```
A binary floor divide is a division that gets rid of the remainder and rounds to the lowest number. `leet` is divided like this and is granted this new value.
`leet = leet//10`
## Line 8
```
  8          74 LOAD_NAME                5 (range)
             76 LOAD_NAME                6 (len)
             78 LOAD_NAME                4 (l)
             80 CALL_FUNCTION            1
             82 LOAD_CONST               3 (2)
             84 BINARY_FLOOR_DIVIDE
             86 CALL_FUNCTION            1
             88 GET_ITER
        >>   90 FOR_ITER                32 (to 124)
             92 STORE_NAME               7 (i)
```
Another for loop. This one iterates only until the half, by using the  floor division, of the length of the entire list `l` of characters
`for i in range(len(l)//2):`
## Line 9
```
  9          94 LOAD_NAME                8 (chr)
             96 LOAD_NAME                9 (ord)
             98 LOAD_NAME                4 (l)
            100 LOAD_NAME                7 (i)
            102 BINARY_SUBSCR
            104 CALL_FUNCTION            1
            106 LOAD_NAME                0 (leet)
            108 LOAD_CONST               2 (10)
            110 BINARY_MODULO
            112 BINARY_ADD
            114 CALL_FUNCTION            1
            116 LOAD_NAME                4 (l)
            118 LOAD_NAME                7 (i)
            120 STORE_SUBSCR
            122 JUMP_ABSOLUTE           90
```
The result of the following operations is also stored in the list `l` of characters in the position `i`:
1. Get the integer representation with `ord` of the character at `l[i]`
2. Do `leet` modulo 10
3. Add the values of step 1 and 2
4. Get the corresponding character that represents that new calculated number
`l[i] = chr((ord(l[i]) + (leet % 10)))`
## Line 10
```
 10     >>  124 LOAD_NAME                0 (leet)
            126 LOAD_CONST               2 (10)
            128 BINARY_FLOOR_DIVIDE
            130 STORE_NAME               0 (leet)
```
Yet another floor division by 10 to the variable `leet` to replace its value
`leet = leet//10`
## Line 11
```
 11         132 LOAD_NAME                5 (range)
            134 LOAD_NAME                6 (len)
            136 LOAD_NAME                4 (l)
            138 CALL_FUNCTION            1
            140 LOAD_CONST               3 (2)
            142 BINARY_FLOOR_DIVIDE
            144 LOAD_NAME                6 (len)
            146 LOAD_NAME                4 (l)
            148 CALL_FUNCTION            1
            150 CALL_FUNCTION            2
            152 GET_ITER
        >>  154 FOR_ITER                32 (to 188)
            156 STORE_NAME               7 (i)
```

A for loop that goes from the half of the list `l` to its end
`for i in range(len(l)//2,len(l)):`
## Line 12
```
 12         158 LOAD_NAME                8 (chr)
            160 LOAD_NAME                9 (ord)
            162 LOAD_NAME                4 (l)
            164 LOAD_NAME                7 (i)
            166 BINARY_SUBSCR
            168 CALL_FUNCTION            1
            170 LOAD_NAME                0 (leet)
            172 LOAD_CONST               2 (10)
            174 BINARY_MODULO
            176 BINARY_SUBTRACT
            178 CALL_FUNCTION            1
            180 LOAD_NAME                4 (l)
            182 LOAD_NAME                7 (i)
            184 STORE_SUBSCR
            186 JUMP_ABSOLUTE          154
```
This is the same as line 6
1. Call the `ord` function to get the integer that represents the character located at `l[i]`
2. Do `leet` modulo 10
3. Subtract to the value of bullet 1 the value of bullet 2
4. Get the corresponding character that represents that new calculated number
`l[i] = chr((ord(l[i]) - (leet % 10)))`
# Line 13
```
13     >>  188 LOAD_NAME                0 (leet)
            190 LOAD_CONST               2 (10)
            192 BINARY_FLOOR_DIVIDE
            194 STORE_NAME               0 (leet)
```
Another floor division by 10 to the `leet` value
`leet = leet//10`
## Line 14
```
 14         196 LOAD_NAME                5 (range)
            198 LOAD_NAME                6 (len)
            200 LOAD_NAME                4 (l)
            202 CALL_FUNCTION            1
            204 CALL_FUNCTION            1
            206 GET_ITER
        >>  208 FOR_ITER                36 (to 246)
            210 STORE_NAME               7 (i)
```
A for loop for the entire length of the list `l`
`for i in range(len(l)):`
## Line 15
```
15         212 LOAD_NAME                8 (chr)
            214 LOAD_NAME                9 (ord)
            216 LOAD_NAME                4 (l)
            218 LOAD_NAME                7 (i)
            220 BINARY_SUBSCR
            222 CALL_FUNCTION            1
            224 LOAD_NAME                7 (i)
            226 LOAD_NAME                0 (leet)
            228 LOAD_CONST               2 (10)
            230 BINARY_MODULO
            232 BINARY_MODULO
            234 BINARY_XOR
            236 CALL_FUNCTION            1
            238 LOAD_NAME                4 (l)
            240 LOAD_NAME                7 (i)
            242 STORE_SUBSCR
            244 JUMP_ABSOLUTE          208
```
The last transformation of the characters in the flag.:
1. It first does leet modulo 10
2. Then it does i modulo the result of step 1
3. Gets the integer value of the letter at l\[i\] and does an XOR with the result of step 2
4. Turns the resulting integer into a character
5. Stores that into the list `l` at position `i`
`l[i] = chr(ord(l[i]) ^ (i % (leet % 10)))`
## Line 17
```
 17     >>  246 LOAD_NAME               10 (print)
            248 LOAD_CONST               4 ('')
            250 LOAD_METHOD             11 (join)
            252 LOAD_NAME                4 (l)
            254 CALL_METHOD              1
            256 CALL_FUNCTION            1
            258 POP_TOP
            260 LOAD_CONST               5 (None)
            262 RETURN_VALUE
None
```
Lastly, it joins all of the characters in the list `l` into a string and prints them
`print(''.join(l))`

Now that we have the script that encodes the flag. Running it by passing it a test flag `he2024{test_flag}` returns `da.,.0wp[ijU\bW]s` , which starts the same way as the flag we're aiming to decode, so that's a great sign.

The next step is to create a script that performs the inverse operations in reverse order to decode the flag. The script is the following:
```
def unscramble():    
    flag = "da.,.0w`-vv[evv[luj^&dUZ'pp*pp)cXb'ds"
    l = list(flag)

    leet = 1 # Last value of leet after the final leet = leet//10

    #Transformations will be done in reverse order from the original script
    for i in range(len(l)):
        # The inverse operation of XOR is another XOR
        l[i] = chr(ord(l[i]) ^ (i % (leet % 10)))

    leet  = 13 # penultimate value of leet = leet//10
    #No need to reverse the operation of the range, as we want to make sure to also transform from the middle of the string to the end
    for i in range(len(l)//2,len(l)):
        #rather than substract, add
        l[i] = chr((ord(l[i]) + (leet % 10)))
    leet = 133 # second value of leet = leet//10

    for i in range(len(l)//2):
        # this time substract, not add
        l[i] = chr((ord(l[i]) - (leet % 10)))
    leet = 1337 # original constant

    for i in range(len(l)):
        # add again
        l[i] = chr((ord(l[i]) + (leet % 10)))

    print(''.join(l))
unscramble()
```
By running the script, we get the decoded flag `he2024{d1zz_izz_pyth0n_d1zz4zz3mbl1n}`

